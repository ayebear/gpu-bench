<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>GPU Shader Benchmark</title>
	<style>
		body {
			margin: 0;
			padding: 0;
			font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
			background: #000;
			color: #fff;
			display: flex;
			flex-direction: column;
			align-items: center;
			justify-content: center;
			height: 100vh;
			overflow: hidden;
		}

		canvas {
			position: absolute;
			top: 0;
			left: 0;
			width: 100%;
			height: 100%;
			z-index: 0;
		}

		.controls {
			position: relative;
			z-index: 10;
			background: rgba(0, 0, 0, 0.8);
			padding: 30px;
			border-radius: 15px;
			backdrop-filter: blur(10px);
			border: 1px solid rgba(255, 255, 255, 0.1);
			text-align: center;
			min-width: 350px;
		}

		h1 {
			margin: 0 0 20px 0;
			font-size: 24px;
			font-weight: 600;
		}

		button {
			background: #0066ff;
			color: white;
			border: none;
			padding: 12px 30px;
			font-size: 16px;
			border-radius: 8px;
			cursor: pointer;
			transition: all 0.3s;
			font-weight: 600;
			margin: 10px 0;
		}

		button:hover {
			background: #0052cc;
			transform: translateY(-1px);
		}

		button:disabled {
			background: #222;
			color: #888;
			cursor: not-allowed;
			transform: none;
		}

		.stats {
			margin: 20px 0;
			font-size: 18px;
			line-height: 1.8;
		}

		.progress-bar {
			width: 100%;
			height: 8px;
			background: rgba(255, 255, 255, 0.1);
			border-radius: 4px;
			overflow: hidden;
			margin: 15px 0;
		}

		.progress-fill {
			height: 100%;
			background: linear-gradient(90deg, #0066ff, #00ccff);
			width: 0%;
			transition: width 0.3s ease;
		}

		.result {
			font-size: 22px;
			font-weight: 600;
			color: #00ccff;
			margin-top: 20px;
		}

		.info {
			font-size: 14px;
			color: #888;
			margin-top: 10px;
			line-height: 1.4;
		}

		.loading {
			color: #0066ff;
			margin: 10px 0;
		}
	</style>
</head>

<body>
	<canvas id="canvas"></canvas>

	<div class="controls">
		<h1>GPU Shader Benchmark</h1>
		<div id="loading" class="loading" style="display: none;">Generating noise texture...</div>
		<button id="startBtn" onclick="toggleBenchmark()" disabled>Start Benchmark</button>
		<div class="stats">
			<div id="frames">Frames: 0</div>
			<div class="progress-bar">
				<div class="progress-fill" id="progress"></div>
			</div>
			<div id="time">Time: 0.0s / 30.0s</div>
		</div>
		<div class="result" id="result"></div>
		<div class="info">
			3840x2160 output resolution<br>
			16384x16384 noise texture
		</div>
	</div>

	<script>
		const canvas = document.getElementById('canvas');
		const gl = canvas.getContext('webgl2');

		if (!gl) {
			alert('WebGL2 not supported!');
		}

		// Fixed render resolution
		const RENDER_WIDTH = 3840;
		const RENDER_HEIGHT = 2160;
		const NOISE_SIZE = 16384;

		// Vertex shader
		const vertexShaderSource = `#version 300 es
        in vec4 a_position;
        void main() {
            gl_Position = a_position;
        }`;

		// Fragment shader - Heavy texture sampling with flow fields
		const fragmentShaderSource = `#version 300 es
        precision highp float;

        uniform float u_time;
        uniform vec2 u_resolution;
        uniform sampler2D u_noiseTexture;
        out vec4 fragColor;

        #define SAMPLES_PER_PIXEL 16
        #define PI 3.14159265359

        // Nested function for complex offset calculation
        vec2 calculateOffset(vec2 base, float index, float time) {
            float angle = index * 0.196349540849 + time * 0.1;
            float radius = index * 0.1 + sin(time + index) * 0.05;

            // Nested calculation
            for (int i = 0; i < 3; i++) {
                angle += sin(angle * 2.0) * 0.1;
                radius *= 1.0 + cos(angle) * 0.1;
            }

            return base + vec2(cos(angle), sin(angle)) * radius;
        }

        // Heavy branching function
        vec3 complexColorMix(vec3 col1, vec3 col2, float factor, float threshold) {
            if (factor < threshold * 0.25) {
                return mix(col1, col2, factor * 4.0);
            } else if (factor < threshold * 0.5) {
                vec3 mid = mix(col1, col2, 0.5);
                return mix(mid, col2, (factor - 0.25) * 4.0);
            } else if (factor < threshold * 0.75) {
                vec3 mid = col1 + col2;
                return mix(col2, mid, (factor - 0.5) * 4.0);
            } else {
                return mix(col2, col1 * col2, (factor - 0.75) * 4.0);
            }
        }

        // Recursive-like sampling with heavy texture lookups
        vec4 sampleFlowField(vec2 uv, float time) {
            vec3 accumColor = vec3(0.0);
            vec2 flowUV = uv;
            float totalWeight = 0.0;

            // 32 texture samples with complex positioning
            for (int i = 0; i < SAMPLES_PER_PIXEL; i++) {
                float fi = float(i);

                // Calculate sample position based on previous samples
                vec2 offset = calculateOffset(flowUV, fi, time);

                // Sample the noise texture
                vec4 noiseSample = texture(u_noiseTexture, offset);

                // Use sampled value to affect next sample position
                flowUV += (noiseSample.xy - 0.5) * 0.02;

                // Complex branching based on noise values
                float threshold = noiseSample.z;
                vec3 color;

                if (noiseSample.x < 0.2) {
                    color = vec3(0.1, 0.3, 0.9) * noiseSample.y;
                    if (noiseSample.y > 0.5) {
                        color = mix(color, vec3(0.9, 0.1, 0.3), noiseSample.z);
                    }
                } else if (noiseSample.x < 0.4) {
                    color = vec3(0.9, 0.1, 0.3) * noiseSample.z;
                    if (noiseSample.w > 0.6) {
                        color = complexColorMix(color, vec3(0.1, 0.9, 0.3), noiseSample.y, threshold);
                    }
                } else if (noiseSample.x < 0.6) {
                    color = vec3(0.1, 0.9, 0.3) * noiseSample.w;
                    for (int j = 0; j < 3; j++) {
                        if (noiseSample[j] > 0.7) {
                            color = mix(color, vec3(0.9, 0.9, 0.1), 0.3);
                        }
                    }
                } else if (noiseSample.x < 0.8) {
                    color = vec3(0.9, 0.9, 0.1);
                    color = complexColorMix(color, vec3(0.5, 0.1, 0.9), noiseSample.y * noiseSample.z, threshold);
                } else {
                    color = vec3(0.5, 0.1, 0.9);
                    if (noiseSample.y * noiseSample.z > 0.5) {
                        color = mix(color, vec3(0.1, 0.5, 0.9), noiseSample.w);
                    }
                }

                // Weight based on distance from center
                float weight = 1.0 / (1.0 + fi * 0.1);
                accumColor += color * weight;
                totalWeight += weight;

                // More texture samples for flow calculation
                vec2 flowOffset = offset + vec2(0.01, 0.0);
                vec4 flowSample = texture(u_noiseTexture, flowOffset);
                flowUV += (flowSample.xy - 0.5) * 0.01 * weight;
            }

            return vec4(accumColor / totalWeight, 1.0);
        }

        void main() {
            vec2 uv = gl_FragCoord.xy / u_resolution.xy;

            // Multiple layers with different time offsets
            vec4 layer1 = sampleFlowField(uv, u_time);
            vec4 layer2 = sampleFlowField(uv + vec2(0.1, 0.0), u_time * 1.3);
            vec4 layer3 = sampleFlowField(uv + vec2(0.0, 0.1), u_time * 0.7);

            // Complex final mixing
            vec3 finalColor = layer1.rgb;
            if (layer2.r > 0.5) {
                finalColor = mix(finalColor, layer2.rgb, 0.5);
            }
            if (layer3.g > 0.5) {
                finalColor = mix(finalColor, layer3.rgb, 0.3);
            }

            // Output
            fragColor = vec4(finalColor, 1.0);
        }`;

		// Copy shaders for display
		const copyVertexShaderSource = `#version 300 es
        in vec4 a_position;
        in vec2 a_texCoord;
        out vec2 v_texCoord;
        void main() {
            gl_Position = a_position;
            v_texCoord = a_texCoord;
        }`;

		const copyFragmentShaderSource = `#version 300 es
        precision highp float;
        uniform sampler2D u_texture;
        in vec2 v_texCoord;
        out vec4 fragColor;
        void main() {
            fragColor = texture(u_texture, v_texCoord);
        }`;

		function createShader(gl, type, source) {
			const shader = gl.createShader(type);
			gl.shaderSource(shader, source);
			gl.compileShader(shader);
			if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
				console.error('Shader compile error:', gl.getShaderInfoLog(shader));
				gl.deleteShader(shader);
				return null;
			}
			return shader;
		}

		function createProgram(gl, vertexShader, fragmentShader) {
			const program = gl.createProgram();
			gl.attachShader(program, vertexShader);
			gl.attachShader(program, fragmentShader);
			gl.linkProgram(program);
			if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
				console.error('Program link error:', gl.getProgramInfoLog(program));
				gl.deleteProgram(program);
				return null;
			}
			return program;
		}

		// Setup shaders
		const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource);
		const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);
		const program = createProgram(gl, vertexShader, fragmentShader);

		const copyVertexShader = createShader(gl, gl.VERTEX_SHADER, copyVertexShaderSource);
		const copyFragmentShader = createShader(gl, gl.FRAGMENT_SHADER, copyFragmentShaderSource);
		const copyProgram = createProgram(gl, copyVertexShader, copyFragmentShader);

		// Get locations
		const positionAttributeLocation = gl.getAttribLocation(program, 'a_position');
		const timeUniformLocation = gl.getUniformLocation(program, 'u_time');
		const resolutionUniformLocation = gl.getUniformLocation(program, 'u_resolution');
		const noiseTextureLocation = gl.getUniformLocation(program, 'u_noiseTexture');

		const copyPositionLocation = gl.getAttribLocation(copyProgram, 'a_position');
		const copyTexCoordLocation = gl.getAttribLocation(copyProgram, 'a_texCoord');
		const copyTextureLocation = gl.getUniformLocation(copyProgram, 'u_texture');

		// Setup buffers
		const positionBuffer = gl.createBuffer();
		gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
		gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
			-1, -1, 1, -1, -1, 1,
			-1, 1, 1, -1, 1, 1
		]), gl.STATIC_DRAW);

		const copyPositionBuffer = gl.createBuffer();
		gl.bindBuffer(gl.ARRAY_BUFFER, copyPositionBuffer);
		gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
			-1, -1, 1, -1, -1, 1,
			-1, 1, 1, -1, 1, 1
		]), gl.STATIC_DRAW);

		const copyTexCoordBuffer = gl.createBuffer();
		gl.bindBuffer(gl.ARRAY_BUFFER, copyTexCoordBuffer);
		gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
			0, 0, 1, 0, 0, 1,
			0, 1, 1, 0, 1, 1
		]), gl.STATIC_DRAW);

		// Setup VAOs
		const vao = gl.createVertexArray();
		gl.bindVertexArray(vao);
		gl.enableVertexAttribArray(positionAttributeLocation);
		gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
		gl.vertexAttribPointer(positionAttributeLocation, 2, gl.FLOAT, false, 0, 0);

		const copyVao = gl.createVertexArray();
		gl.bindVertexArray(copyVao);
		gl.enableVertexAttribArray(copyPositionLocation);
		gl.bindBuffer(gl.ARRAY_BUFFER, copyPositionBuffer);
		gl.vertexAttribPointer(copyPositionLocation, 2, gl.FLOAT, false, 0, 0);
		gl.enableVertexAttribArray(copyTexCoordLocation);
		gl.bindBuffer(gl.ARRAY_BUFFER, copyTexCoordBuffer);
		gl.vertexAttribPointer(copyTexCoordLocation, 2, gl.FLOAT, false, 0, 0);

		// Create framebuffer for rendering
		const framebuffer = gl.createFramebuffer();
		const renderTexture = gl.createTexture();
		gl.bindTexture(gl.TEXTURE_2D, renderTexture);
		gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, RENDER_WIDTH, RENDER_HEIGHT, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

		gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);
		gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, renderTexture, 0);

		// Generate noise texture
		let noiseTexture;

		function generateNoiseTexture() {
			document.getElementById('loading').style.display = 'block';
			document.getElementById('startBtn').disabled = true;

			setTimeout(() => {
				const noiseData = new Uint8Array(NOISE_SIZE * NOISE_SIZE * 4);

				// Generate random noise
				for (let i = 0; i < noiseData.length; i++) {
					noiseData[i] = Math.floor(Math.random() * 256);
				}

				noiseTexture = gl.createTexture();
				gl.bindTexture(gl.TEXTURE_2D, noiseTexture);
				gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, NOISE_SIZE, NOISE_SIZE, 0, gl.RGBA, gl.UNSIGNED_BYTE, noiseData);
				gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
				gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
				gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT);
				gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT);

				document.getElementById('loading').style.display = 'none';
				document.getElementById('startBtn').disabled = false;
			}, 100);
		}

		// Benchmark state
		let isRunning = false;
		let startTime = 0;
		let frameCount = 0;
		let animationId = null;

		function resizeCanvas() {
			canvas.width = window.innerWidth;
			canvas.height = window.innerHeight;
		}

		window.addEventListener('resize', resizeCanvas);
		resizeCanvas();

		function render() {
			if (!isRunning) return;
			let elapsed = (performance.now() - startTime) / 1000;

			// Render to framebuffer
			gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);
			gl.viewport(0, 0, RENDER_WIDTH, RENDER_HEIGHT);
			gl.useProgram(program);
			gl.bindVertexArray(vao);

			// Bind noise texture
			gl.activeTexture(gl.TEXTURE0);
			gl.bindTexture(gl.TEXTURE_2D, noiseTexture);
			gl.uniform1i(noiseTextureLocation, 0);

			gl.uniform1f(timeUniformLocation, elapsed);
			gl.uniform2f(resolutionUniformLocation, RENDER_WIDTH, RENDER_HEIGHT);
			gl.drawArrays(gl.TRIANGLES, 0, 6);

			// Copy to screen
			gl.bindFramebuffer(gl.FRAMEBUFFER, null);
			gl.viewport(0, 0, canvas.width, canvas.height);
			gl.useProgram(copyProgram);
			gl.bindVertexArray(copyVao);
			gl.activeTexture(gl.TEXTURE0);
			gl.bindTexture(gl.TEXTURE_2D, renderTexture);
			gl.uniform1i(copyTextureLocation, 0);
			gl.drawArrays(gl.TRIANGLES, 0, 6);

			frameCount++;
			elapsed = (performance.now() - startTime) / 1000;
			const progress = Math.min(elapsed / 30, 1);

			// Update UI
			document.getElementById('frames').textContent = `Frames: ${frameCount}`;
			document.getElementById('progress').style.width = `${progress * 100}%`;
			document.getElementById('time').textContent = `Time: ${elapsed.toFixed(1)}s / 30.0s`;

			if (elapsed >= 30) {
				stopBenchmark();
				return;
			}
			animationId = requestAnimationFrame(render);
		}

		function startBenchmark() {
			isRunning = true;
			startTime = performance.now();
			frameCount = 0;
			document.getElementById('startBtn').textContent = 'Stop';
			document.getElementById('result').textContent = '';
			animationId = requestAnimationFrame(render);
		}

		function stopBenchmark() {
			isRunning = false;
			if (animationId) {
				cancelAnimationFrame(animationId);
			}

			const elapsed = (performance.now() - startTime) / 1000;
			const fps = frameCount / elapsed;

			document.getElementById('result').textContent =
				`${fps.toFixed(2)} FPS (${frameCount} frames in ${elapsed.toFixed(1)}s)`;
			document.getElementById('startBtn').textContent = 'Start Benchmark';
		}

		function toggleBenchmark() {
			if (isRunning) {
				stopBenchmark();
			} else {
				startBenchmark();
			}
		}

		// Initialize
		generateNoiseTexture();
	</script>
</body>

</html>